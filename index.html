<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Advanced Submarine Battle Simulator</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; }
        .info {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.5);
            color: white;
            padding: 10px;
            border-radius: 5px;
            font-family: Arial, sans-serif;
            z-index: 100;
        }
        
        /* UI Elements */
        #controls-info {
            position: absolute;
            top: 10px;
            left: 10px;
            background-color: rgba(0, 0, 0, 0.5);
            color: white;
            padding: 5px 10px;
            border-radius: 5px;
            font-family: Arial, sans-serif;
            font-size: 14px;
            z-index: 100;
        }
        
        #dashboard {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 15px;
            border-radius: 10px;
            font-family: 'Courier New', monospace;
            z-index: 100;
            display: flex;
            gap: 20px;
        }
        
        .gauge {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        .gauge-title {
            font-size: 12px;
            margin-bottom: 5px;
            color: #aaa;
        }
        
        .gauge-value {
            font-size: 18px;
            font-weight: bold;
        }
        
        .compass {
            width: 100px;
            height: 100px;
            border-radius: 50%;
            background-color: #222;
            position: relative;
            border: 2px solid #444;
        }
        
        .compass-needle {
            position: absolute;
            top: 10px;
            left: 50%;
            width: 2px;
            height: 40px;
            background: linear-gradient(to bottom, red 0%, red 50%, white 50%, white 100%);
            transform-origin: bottom center;
        }
        
        .compass-labels {
            position: absolute;
            width: 100%;
            height: 100%;
            top: 0;
            left: 0;
        }
        
        .compass-label {
            position: absolute;
            font-size: 12px;
            font-weight: bold;
        }
        
        .north { top: 5px; left: 50%; transform: translateX(-50%); color: red; }
        .east { top: 50%; right: 5px; transform: translateY(-50%); }
        .south { bottom: 5px; left: 50%; transform: translateX(-50%); }
        .west { top: 50%; left: 5px; transform: translateY(-50%); }
    </style>
</head>
<body>
    <div id="controls-info">Controls: Arrow keys to move, T to surface, G to dive, SPACE to shoot torpedoes</div>
    
    <div id="dashboard">
        <div class="gauge">
            <div class="gauge-title">DEPTH</div>
            <div class="gauge-value" id="depth-value">0 m</div>
        </div>
        <div class="gauge">
            <div class="gauge-title">SPEED</div>
            <div class="gauge-value" id="speed-value">0 knots</div>
        </div>
        <div class="gauge">
            <div class="compass">
                <div class="compass-needle" id="compass-needle"></div>
                <div class="compass-labels">
                    <div class="compass-label north">N</div>
                    <div class="compass-label east">E</div>
                    <div class="compass-label south">S</div>
                    <div class="compass-label west">W</div>
                </div>
            </div>
            <div class="gauge-title">HEADING</div>
        </div>
    </div>
    
    <script type="module">
        import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.module.js';
        
        // Scene setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);
        
        // Lighting
        const sunLight = new THREE.DirectionalLight(0xffffff, 1.2);
        sunLight.position.set(0, 100, 100);
        scene.add(sunLight);
        
        const ambientLight = new THREE.AmbientLight(0x00008b, 0.5);
        scene.add(ambientLight);
        
        // Initial fog
        scene.fog = new THREE.FogExp2(0x00008b, 0.025);
        
        // Game variables
        let submarine;
        let water;
        let sky;
        const underwaterObjects = [];
        let torpedoes = []; // Initialize torpedoes array
        let keys = {}; // Changed from const to let
        let targetY = -15; // Default submarine depth
        const waterLevel = 0;
        
        // Create water surface
        function createWaterSurface() {
            // Create a more realistic water texture
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = 1024;
            canvas.height = 1024;
            
            // Create solid lighter blue background
            ctx.fillStyle = '#0099cc';  // Lighter blue
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Add subtle wave patterns
            ctx.globalAlpha = 0.2;
            
            // Draw multiple subtle wave layers with similar light blue colors
            drawWavePattern(ctx, canvas.width, canvas.height, 25, '#00b8e6', 0.15);
            drawWavePattern(ctx, canvas.width, canvas.height, 40, '#33ccff', 0.1);
            
            // Add some noise texture
            addNoiseTexture(ctx, canvas.width, canvas.height, 0.03);
            
            // Add subtle highlights
            addHighlights(ctx, canvas.width, canvas.height, 0.08);
            
            // Reset alpha
            ctx.globalAlpha = 1.0;
            
            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            texture.repeat.set(6, 6);  // Reduced repeat to make pattern less obvious
            
            // Water material with improved texture
            const waterMaterial = new THREE.MeshPhongMaterial({
                color: 0x0099cc, // Consistent lighter blue
                map: texture,
                shininess: 100,
                specular: 0xffffff,
                transparent: true,
                opacity: 0.8,
                side: THREE.FrontSide
            });
            
            // Water geometry (large plane)
            const waterGeometry = new THREE.PlaneGeometry(1000, 1000, 50, 50);
            water = new THREE.Mesh(waterGeometry, waterMaterial);
            water.rotation.x = -Math.PI / 2;
            water.position.y = waterLevel;
            
            // Add vertices displacement for waves
            const vertices = water.geometry.attributes.position.array;
            const waves = [];
            for (let i = 0; i < vertices.length; i += 3) {
                waves.push({
                    x: vertices[i],
                    y: vertices[i + 1],
                    z: vertices[i + 2],
                    ang: Math.random() * Math.PI * 2,
                    amp: Math.random() * 0.1 + 0.1,
                    speed: Math.random() * 0.05 + 0.02
                });
            }
            water.waves = waves;
            
            scene.add(water);
            return water;
        }
        
        // Helper function to draw wave patterns
        function drawWavePattern(ctx, width, height, waveHeight, color, opacity) {
            ctx.strokeStyle = color;
            ctx.lineWidth = 0.5;  // Thinner lines
            ctx.globalAlpha = opacity;
            
            for (let y = 0; y < height; y += waveHeight) {
                ctx.beginPath();
                
                // Start at the left edge
                ctx.moveTo(0, y);
                
                // Create a wavy line across the canvas
                for (let x = 0; x < width; x += 15) {
                    const variance = Math.random() * waveHeight / 3;
                    ctx.lineTo(x, y + variance);
                }
                
                ctx.stroke();
            }
        }
        
        // Helper function to add noise texture
        function addNoiseTexture(ctx, width, height, intensity) {
            ctx.globalAlpha = intensity;
            
            for (let i = 0; i < width * height * 0.05; i++) {
                const x = Math.random() * width;
                const y = Math.random() * height;
                const radius = Math.random() * 2 + 0.5;
                
                ctx.beginPath();
                ctx.arc(x, y, radius, 0, Math.PI * 2);
                
                // Random blue-white shade
                const shade = Math.floor(Math.random() * 100 + 155);
                ctx.fillStyle = `rgb(${shade}, ${shade + 30}, ${shade + 50})`;
                ctx.fill();
            }
        }
        
        // Helper function to add highlights
        function addHighlights(ctx, width, height, intensity) {
            ctx.globalAlpha = intensity;
            
            for (let i = 0; i < 100; i++) {
                const x = Math.random() * width;
                const y = Math.random() * height;
                const radius = Math.random() * 5 + 1;
                
                // Create radial gradient for highlight
                const gradient = ctx.createRadialGradient(x, y, 0, x, y, radius);
                gradient.addColorStop(0, 'rgba(255, 255, 255, 0.8)');
                gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
                
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(x, y, radius, 0, Math.PI * 2);
                ctx.fill();
            }
        }
        
        // Create skybox
        function createSkybox() {
            // Skybox
            const skyGeometry = new THREE.SphereGeometry(500, 32, 32);
            const skyMaterial = new THREE.MeshBasicMaterial({
                color: 0x99D6FF, // Bright blue
                side: THREE.BackSide
            });
            sky = new THREE.Mesh(skyGeometry, skyMaterial);
            scene.add(sky);
            
            // Create clouds
            const clouds = [];
            for (let i = 0; i < 20; i++) {
                const cloudGeometry = new THREE.SphereGeometry(Math.random() * 10 + 5, 8, 8);
                const cloudMaterial = new THREE.MeshBasicMaterial({
                    color: 0xffffff,
                    transparent: true,
                    opacity: 0.8
                });
                const cloud = new THREE.Mesh(cloudGeometry, cloudMaterial);
                cloud.position.set(
                    Math.random() * 400 - 200,
                    Math.random() * 50 + 50,
                    Math.random() * 400 - 200
                );
                scene.add(cloud);
                clouds.push(cloud);
            }
            
            return { sky, clouds };
        }
        
        // Create environment objects
        function createEnvironmentObjects() {
            // Ocean floor
            const floorGeometry = new THREE.PlaneGeometry(1000, 1000);
            const floorMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x553311, // Sandy brown
                transparent: true, 
                opacity: 0.8
            });
            
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = -Math.PI / 2;
            floor.position.y = -25;
            scene.add(floor);
            
            // Rocks
            const rockGeometry = new THREE.SphereGeometry(2, 16, 16);
            const rockMaterial = new THREE.MeshPhongMaterial({ color: 0x666666 });
            
            const rock1 = new THREE.Mesh(rockGeometry, rockMaterial);
            rock1.position.set(-10, -23, -10);
            scene.add(rock1);
            underwaterObjects.push(rock1);
            
            const rock2 = new THREE.Mesh(rockGeometry, rockMaterial);
            rock2.position.set(15, -24, 5);
            rock2.scale.set(1.5, 1.5, 1.5);
            scene.add(rock2);
            underwaterObjects.push(rock2);
            
            const rock3 = new THREE.Mesh(rockGeometry, rockMaterial);
            rock3.position.set(-5, -24, 20);
            rock3.scale.set(0.7, 0.7, 0.7);
            scene.add(rock3);
            underwaterObjects.push(rock3);
            
            // Corals
            for (let i = 0; i < 20; i++) {
                createCoral(
                    Math.random() * 100 - 50,
                    Math.random() * 100 - 50
                );
            }
            
            // Plants
            for (let i = 0; i < 30; i++) {
                createPlant(
                    Math.random() * 120 - 60,
                    Math.random() * 120 - 60
                );
            }
            
            // Islands
            createIsland(-40, -60, 10); // Large island
            createIsland(50, 30, 8);    // Medium island
            createIsland(-20, 40, 5);   // Small island
            createIsland(70, -40, 6);   // Another island
            
            // Bubbles
            const bubbleCount = 100;
            const bubbleGeometry = new THREE.BufferGeometry();
            const bubblePositions = new Float32Array(bubbleCount * 3);
            
            for (let i = 0; i < bubbleCount * 3; i += 3) {
                bubblePositions[i] = Math.random() * 100 - 50; // x
                bubblePositions[i + 1] = -Math.random() * 20 - 5; // y
                bubblePositions[i + 2] = Math.random() * 100 - 50; // z
            }
            
            bubbleGeometry.setAttribute('position', new THREE.BufferAttribute(bubblePositions, 3));
            const bubbleMaterial = new THREE.PointsMaterial({
                color: 0xffffff,
                size: 0.3,
                transparent: true,
                opacity: 0.6
            });
            
            const bubbles = new THREE.Points(bubbleGeometry, bubbleMaterial);
            scene.add(bubbles);
            underwaterObjects.push(bubbles);
            
            return { floor, bubbles };
        }
        
        function createCoral(x, z) {
            const coralGeometry = new THREE.ConeGeometry(2, 5, 32);
            const coralMaterial = new THREE.MeshPhongMaterial({
                color: Math.random() > 0.5 ? 0xff6699 : 0xffaa00 
            });
            const coral = new THREE.Mesh(coralGeometry, coralMaterial);
            
            coral.position.set(x, -22, z);
            coral.rotation.y = Math.random() * Math.PI;
            scene.add(coral);
            underwaterObjects.push(coral);
        }
        
        function createPlant(x, z) {
            const plantGeometry = new THREE.CylinderGeometry(0.2, 0.5, 8, 8);
            const plantMaterial = new THREE.MeshPhongMaterial({ color: 0x00aa00 });
            const plant = new THREE.Mesh(plantGeometry, plantMaterial);
            
            plant.position.set(x, -21, z);
            plant.rotation.x = Math.random() * 0.2;
            plant.rotation.z = Math.random() * 0.2;
            scene.add(plant);
            underwaterObjects.push(plant);
        }
        
        function createIsland(x, z, size) {
            // Island base (above water)
            const islandGeometry = new THREE.CylinderGeometry(size, size * 1.2, 1, 32);
            const islandMaterial = new THREE.MeshPhongMaterial({ color: 0xddbb88 }); // Sandy color
            const island = new THREE.Mesh(islandGeometry, islandMaterial);
            island.position.set(x, 0.5, z); // Slightly above water
            scene.add(island);
            
            // Island underwater part
            const underwaterGeometry = new THREE.CylinderGeometry(size * 1.2, size * 0.8, 25, 32);
            const underwaterMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x553311, 
                transparent: true,
                opacity: 0.9
            });
            const underwaterPart = new THREE.Mesh(underwaterGeometry, underwaterMaterial);
            underwaterPart.position.set(x, -12, z); // Below water
            scene.add(underwaterPart);
            underwaterObjects.push(underwaterPart);
            
            // Add palm trees to island
            const palmCount = Math.floor(Math.random() * 3) + 1;
            for (let i = 0; i < palmCount; i++) {
                createPalmTree(
                    x + Math.random() * size * 0.5 - size * 0.25,
                    z + Math.random() * size * 0.5 - size * 0.25,
                    size * 0.15
                );
            }
        }
        
        function createPalmTree(x, z, size) {
            // Palm trunk
            const trunkGeometry = new THREE.CylinderGeometry(size * 0.2, size * 0.3, size * 5, 8);
            const trunkMaterial = new THREE.MeshPhongMaterial({ color: 0x8B4513 }); // Brown
            const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
            trunk.position.set(x, size * 2.5 + 0.5, z); // Above island
            scene.add(trunk);
            
            // Palm leaves
            const leavesGeometry = new THREE.ConeGeometry(size * 2, size * 3, 8);
            const leavesMaterial = new THREE.MeshPhongMaterial({ color: 0x228B22 }); // Forest green
            const leaves = new THREE.Mesh(leavesGeometry, leavesMaterial);
            leaves.position.set(x, size * 5 + 0.5, z); // Top of trunk
            leaves.rotation.x = Math.PI * 0.1; // Tilt slightly
            leaves.rotation.z = Math.random() * Math.PI * 2; // Random rotation
            scene.add(leaves);
        }
        
        // Create submarine
        function createSubmarine() {
            // Submarine body - simple cylinder for now
            const bodyGeometry = new THREE.CylinderGeometry(1, 1, 6, 16);
            const bodyMaterial = new THREE.MeshPhongMaterial({ color: 0x333344 });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.rotation.x = Math.PI / 2; // Rotate to horizontal position
            
            // Submarine conning tower (sail)
            const towerGeometry = new THREE.CylinderGeometry(0.5, 0.5, 1.5, 8);
            const towerMaterial = new THREE.MeshPhongMaterial({ color: 0x333344 });
            const tower = new THREE.Mesh(towerGeometry, towerMaterial);
            tower.position.y = 1;
            
            // Group all submarine parts
            submarine = new THREE.Group();
            submarine.add(body);
            submarine.add(tower);
            
            // Set initial position
            submarine.position.set(0, -5, 0);
            
            // Add physics properties
            submarine.velocity = new THREE.Vector3(0, 0, 0);
            submarine.direction = new THREE.Vector3(0, 0, 1); // Forward direction vector
            submarine.rotationSpeed = 0.03;
            submarine.maxSpeed = 0.3;
            submarine.acceleration = 0.01;
            submarine.drag = 0.98;
            
            // Add to scene
            scene.add(submarine);
            
            return submarine;
        }
        
        // Set up controls
        function setupControls() {
            // Track key states
            keys = {};
            
            // Key down event
            document.addEventListener('keydown', (event) => {
                keys[event.key] = true;
                
                // Handle torpedo firing with spacebar
                if (event.code === 'Space') {
                    fireTorpedo();
                }
            });
            
            // Key up event
            document.addEventListener('keyup', (event) => {
                keys[event.key] = false;
            });
        }
        
        // Shoot torpedo
        function fireTorpedo() {
            if (!submarine) return;
            
            const torpedoGeometry = new THREE.SphereGeometry(0.5, 32, 32);
            const torpedoMaterial = new THREE.MeshPhongMaterial({ 
                color: 0xffff00,
                emissive: 0xffff00,
                emissiveIntensity: 0.5
            });
            
            const torpedo = new THREE.Mesh(torpedoGeometry, torpedoMaterial);
            
            // Position torpedo at submarine's front
            torpedo.position.copy(submarine.position);
            torpedo.position.z -= 5 * Math.cos(submarine.rotation.y);
            torpedo.position.x -= 5 * Math.sin(submarine.rotation.y);
            
            // Set torpedo direction based on submarine's direction
            torpedo.direction = submarine.direction.clone();
            torpedo.speed = 1.0; // Torpedo speed
            torpedo.lifeTime = 100; // How long the torpedo lives before disappearing
            
            // Add to scene and torpedoes array
            scene.add(torpedo);
            torpedoes.push(torpedo);
        }
        
        // Update torpedo positions
        function updateTorpedoes() {
            for (let i = torpedoes.length - 1; i >= 0; i--) {
                const torpedo = torpedoes[i];
                
                // Move torpedo forward in its direction
                torpedo.position.x -= torpedo.direction.x * torpedo.speed;
                torpedo.position.z -= torpedo.direction.z * torpedo.speed;
                
                // Apply slight downward trajectory underwater
                if (torpedo.position.y < waterLevel) {
                    torpedo.position.y -= 0.05;
                }
                
                // Decrease lifetime
                torpedo.lifeTime--;
                
                // Remove torpedo if it's too old
                if (torpedo.lifeTime <= 0) {
                    scene.remove(torpedo);
                    torpedoes.splice(i, 1);
                }
            }
        }
        
        // Animation functions
        function animateWater(time) {
            if (!water || !water.waves) return;
            
            const vertices = water.geometry.attributes.position.array;
            const waves = water.waves;
            
            for (let i = 0; i < vertices.length / 3; i++) {
                const wave = waves[i];
                vertices[i * 3 + 2] = wave.z + Math.sin(wave.ang) * wave.amp;
                wave.ang += wave.speed;
            }
            
            water.geometry.attributes.position.needsUpdate = true;
        }
        
        function animateClouds(time) {
            if (!sky) return;
            
            // Animate clouds if needed
        }
        
        function animateBubbles(cameraY) {
            const bubbles = underwaterObjects.find(obj => obj instanceof THREE.Points);
            if (!bubbles) return;
            
            // Only animate bubbles when underwater
            if (cameraY < 0) {
                const bubblePositions = bubbles.geometry.attributes.position.array;
                for (let i = 1; i < bubblePositions.length; i += 3) {
                    bubblePositions[i] += 0.05; // Move bubbles upward
                    
                    // Reset bubbles that reach the surface
                    if (bubblePositions[i] > -1) {
                        bubblePositions[i] = -25; // Reset to bottom
                        bubblePositions[i - 1] = Math.random() * 100 - 50; // New x
                        bubblePositions[i + 1] = Math.random() * 100 - 50; // New z
                    }
                }
                bubbles.geometry.attributes.position.needsUpdate = true;
                bubbles.visible = true;
            } else {
                // Hide bubbles when above water
                bubbles.visible = false;
            }
        }
        
        function updateWaterAppearance(cameraY) {
            if (!water) return;
            
            // Update water appearance based on camera position
            if (cameraY < waterLevel) {
                // Underwater
                water.material.opacity = 0.7; // More opaque underwater
                water.material.color.setHex(0x003366); // Lighter blue underwater
                
                // Show underwater objects
                underwaterObjects.forEach(obj => {
                    if (obj) obj.visible = true;
                });
            } else {
                // Above water
                water.material.opacity = 0.8; // More transparent above water
                water.material.color.setHex(0x001a33); // Darker blue from above
                
                // Hide underwater objects
                underwaterObjects.forEach(obj => {
                    if (obj) obj.visible = false;
                });
            }
        }
        
        function updateSkyFog(cameraY) {
            // Update fog based on camera position
            if (cameraY < waterLevel) {
                // Underwater fog (denser, blue-green)
                scene.fog.color.setHex(0x003366);
                scene.fog.density = 0.04;
            } else {
                // Above water fog (less dense, sky blue)
                scene.fog.color.setHex(0x99D6FF);
                scene.fog.density = 0.01;
            }
        }
        
        // Update submarine position based on controls
        function updateSubmarinePosition() {
            // Apply drag to slow down
            submarine.velocity.multiplyScalar(submarine.drag);
            
            // Handle keyboard controls
            if (keys.ArrowUp) {
                // Accelerate forward
                submarine.velocity.z += submarine.acceleration * Math.cos(submarine.rotation.y);
                submarine.velocity.x += submarine.acceleration * Math.sin(submarine.rotation.y);
                
                // Update direction vector
                submarine.direction.set(Math.sin(submarine.rotation.y), 0, Math.cos(submarine.rotation.y));
            }
            if (keys.ArrowDown) {
                // Decelerate/reverse
                submarine.velocity.z -= submarine.acceleration * Math.cos(submarine.rotation.y);
                submarine.velocity.x -= submarine.acceleration * Math.sin(submarine.rotation.y);
                
                // Update direction vector
                submarine.direction.set(-Math.sin(submarine.rotation.y), 0, -Math.cos(submarine.rotation.y));
            }
            if (keys.ArrowLeft) {
                // Turn left
                submarine.rotation.y += submarine.rotationSpeed;
                
                // Update direction vector
                submarine.direction.set(Math.sin(submarine.rotation.y), 0, Math.cos(submarine.rotation.y));
            }
            if (keys.ArrowRight) {
                // Turn right
                submarine.rotation.y -= submarine.rotationSpeed;
                
                // Update direction vector
                submarine.direction.set(Math.sin(submarine.rotation.y), 0, Math.cos(submarine.rotation.y));
            }
            if (keys.t) {
                // Surface
                if (submarine.position.y < waterLevel - 1) {
                    submarine.velocity.y = 0.1;
                }
            }
            if (keys.g) {
                // Dive
                submarine.velocity.y = -0.1;
            }
            
            // Limit maximum speed
            const speed = submarine.velocity.length();
            if (speed > submarine.maxSpeed) {
                submarine.velocity.normalize().multiplyScalar(submarine.maxSpeed);
            }
            
            // Update position based on velocity
            submarine.position.add(submarine.velocity);
            
            // Limit depth - don't go above water or below seabed
            if (submarine.position.y > waterLevel - 1) {
                submarine.position.y = waterLevel - 1;
                submarine.velocity.y = 0;
            }
            if (submarine.position.y < -30) {
                submarine.position.y = -30;
                submarine.velocity.y = 0;
            }
        }
        
        // Update camera position to follow submarine
        function updateCamera() {
            if (!submarine) return;
            
            camera.position.set(
                submarine.position.x, 
                submarine.position.y + 5, 
                submarine.position.z + 15
            );
            camera.lookAt(
                submarine.position.x, 
                submarine.position.y, 
                submarine.position.z
            );
        }
        
        // Update UI elements
        function updateUI() {
            // Only update if submarine exists
            if (!submarine) return;
            
            // Update depth gauge
            const depth = Math.abs(submarine.position.y - waterLevel);
            document.getElementById('depth-value').textContent = depth.toFixed(1) + ' m';
            
            // Update speed gauge
            const speed = Math.sqrt(
                submarine.velocity.x * submarine.velocity.x + 
                submarine.velocity.z * submarine.velocity.z
            ) * 10; // Scale for display
            document.getElementById('speed-value').textContent = speed.toFixed(1) + ' knots';
            
            // Update compass - only if submarine has direction property
            if (submarine.direction) {
                const angle = Math.atan2(submarine.direction.x, submarine.direction.z);
                const degrees = angle * (180 / Math.PI);
                document.getElementById('compass-needle').style.transform = `rotate(${degrees}deg)`;
            }
        }
        
        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            const time = performance.now() * 0.001;
            
            // Animate water waves
            animateWater(time);
            
            // Animate clouds
            animateClouds(time);
            
            // Animate bubbles
            animateBubbles(camera.position.y);
            
            // Update submarine position
            updateSubmarinePosition();
            
            // Update torpedoes
            updateTorpedoes();
            
            // Update camera to follow submarine
            updateCamera();
            
            // Update environment based on camera position
            updateWaterAppearance(camera.position.y);
            updateSkyFog(camera.position.y);
            
            // Update UI elements
            updateUI();
            
            // Render the scene
            renderer.render(scene, camera);
        }
        
        // Initialize the game
        function initGame() {
            // Create environment
            createWaterSurface();
            createSkybox();
            createEnvironmentObjects();
            
            // Create submarine
            createSubmarine();
            
            // Initialize torpedoes array
            torpedoes = [];
            
            // Set up controls
            setupControls();
            
            // Start animation loop
            animate();
            
            // Handle window resize
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }
        
        // Start the game when the DOM is loaded
        document.addEventListener('DOMContentLoaded', initGame);
    </script>
</body>
</html>
